<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        继承
    </title>
</head>
<body>
    
</body>
</html>
<script>
    /*
    当函数本身中没有需要访问的属性或者方法的时候,会检查原型中的属性和方法,如果函数本身具有需要访问的属性或方法,则不会再去检查原型中的属性和方法
    */
   function Fu(name,age){
    this.name = name;
    this.age = age;
    //构造函数里面的方法

    // this.eat = function(){
    //     console.log(this.name + '一口水');
    // }
   }
   Fu.prototype.eat  = function(){
    console.log(this.name + "吃十桶饭");
   };

   function Son(name,age){
    this.name = name;
    this.age = age;
   }

  Son.prototype = Fu.prototype;
  console.log(Fu.prototype);
  console.log('============');
// Son.prototype = new Fu();
    console.log(Son.prototype.constructor);  
  Son.prototype.constructor = Son;  
   let f1 = new Fu('孙悟空',16);
   f1.eat();
  let s1 = new Son('孙悟天',18);
  s1.eat();

//   console.log(s1.__proto__ );

// 原型使用


console.log( Array.prototype);
Array.prototype.aa = function(){
    let newArr = [];
    for(let i=0;i<this.length;i++){
        if(!newArr.includes(this[i])){
            newArr.push(this[i]);
        }
    }
    return newArr;
}
let arr1 = [1,2,3,4,5,1,2,3,4,5,6,7,8];
let arr2 =  arr1.aa();
console.log(arr2);
</script>