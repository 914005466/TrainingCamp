<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>原型</title>
</head>
<body>
    
</body>
</html>
<script>
    function Show(name,age,sex,say){
        this.name = name;
        this.age = age;
        this.sex = sex;
        this.say = say;
        this.fun = function(){
            console.log(this.name);
        }
        this.eat = function(){
            console.log(this.name+'喝二斤酒');
        }
    }
    //在构造函数原型上写方法
    Show.prototype.run = function(){
        console.log(this.name+'快跑');
    }
    Show.prototype.eat = function(){
        console.log(this.name+'吃米饭');
    }
  let s = new  Show('张飞','20','男','张飞吃豆芽');
    console.log(s);
    console.log(Show.prototype);
    let s1 = new Show('关羽','25','男','关羽吃玉米');
    console.log(s1);
    /*
    原型:指的是构造函数创建出来的所有对象的模版
    只有构造函数有原型
    原型 prototype ,他是一个对象,一般的在创建构造函数的时候,会把构造函数中的方法写在原型上

    一个构造函数(1)原型的构造函数(2)指的是该构造函数(1)

    构造函数可以通过原型做继承
    */
   console.log(s instanceof Show);
   console.log(s1 instanceof Show);
   s.eat();
   s1.eat();

   console.log(Show.prototype.constructor === Show);

   //继承
   function Son(name,age,sex,say){
    this.name = name;  
    this.age = age;
    this.sex = sex;
    this.say = say;
   }
   //把父类的原型赋值给 子类
   Son.prototype = Show.prototype;
   //把子类原型的构造函数指向子类
   Son.prototype.constructor = Son;

   console.log(Son.prototype.constructor === Show);
   let s2 = new Son('赵云','20','男','赵云吃虎皮');
   let s3 = new Son('悟天','20','男','悟天啥也不吃');
   s2.eat();
   s3.eat();
</script>